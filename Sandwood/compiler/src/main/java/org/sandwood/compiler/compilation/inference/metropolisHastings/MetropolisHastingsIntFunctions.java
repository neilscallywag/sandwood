/*
 * Sandwood
 *
 * Copyright (c) 2019-2024, Oracle and/or its affiliates
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/
 */

package org.sandwood.compiler.compilation.inference.metropolisHastings;

import static org.sandwood.compiler.trees.irTree.IRTree.addDI;
import static org.sandwood.compiler.trees.irTree.IRTree.addII;
import static org.sandwood.compiler.trees.irTree.IRTree.castToInteger;
import static org.sandwood.compiler.trees.irTree.IRTree.conditionalAssignment;
import static org.sandwood.compiler.trees.irTree.IRTree.constant;
import static org.sandwood.compiler.trees.irTree.IRTree.lessThan;
import static org.sandwood.compiler.trees.irTree.IRTree.functionCallReturn;
import static org.sandwood.compiler.trees.irTree.IRTree.initializeVariable;
import static org.sandwood.compiler.trees.irTree.IRTree.lessThanEqual;
import static org.sandwood.compiler.trees.irTree.IRTree.load;
import static org.sandwood.compiler.trees.irTree.IRTree.multiplyID;
import static org.sandwood.compiler.trees.irTree.IRTree.multiplyDD;
import static org.sandwood.compiler.trees.irTree.IRTree.multiplyII;
import static org.sandwood.compiler.trees.irTree.IRTree.store;
import static org.sandwood.compiler.trees.irTree.IRTree.subtractDI;

import java.util.List;

import org.sandwood.compiler.compilation.CompilationContext;
import org.sandwood.compiler.compilation.FunctionType;
import org.sandwood.compiler.dataflowGraph.scopes.GlobalScope;
import org.sandwood.compiler.dataflowGraph.tasks.returnTasks.SampleTask;
import org.sandwood.compiler.dataflowGraph.variables.VariableDescription;
import org.sandwood.compiler.dataflowGraph.variables.VariableType;
import org.sandwood.compiler.dataflowGraph.variables.randomVariables.RandomVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.BooleanVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.DoubleVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.IntVariable;
import org.sandwood.compiler.names.VariableNames;
import org.sandwood.compiler.trees.Tree;
import org.sandwood.compiler.trees.irTree.IRTree;
import org.sandwood.compiler.trees.irTree.IRTreeReturn;
import org.sandwood.compiler.trees.irTree.IRTreeVoid;

/**
 * A class to perform Metropolis-Hastings to generate a sample value. To prevent probabilities going to zero the
 * probabilities are generated and stored in log space. The proposed value is generated by adding a constant to the
 * current value.
 * 
 * To construct the offset value if the value is 0 the offset is drawn from a Gaussian with mean 0 and variance of 3. If
 * the offset is not 0 the sample is drawn from a Gaussian with mean 0 and variance 0.001 times the current sample
 * value. The offset will then have 1 added or removed to ensure the offset is not 0 when cast to an integer. The
 * special case for 0 is required to stop the offset being deterministically -1.
 *
 * The parameters for the gaussian for non-zero values are picked to give average offsets that are %5 of the size of the
 * current value.
 */

public class MetropolisHastingsIntFunctions<B extends RandomVariable<IntVariable, B>>
        extends MetropolisHastingsScalarFunctions<IntVariable, B> {
    /**
     * Method to select a proposed value.
     */
    @Override
    protected void getProposedValue(MetropolisHastingsData<IntVariable, B> funcData,
            CompilationContext compilationCtx) {
        VariableDescription<DoubleVariable> varName = VariableNames.calcVarName("var", VariableType.DoubleVariable,
                true);
        VariableDescription<DoubleVariable> offsetName = VariableNames.calcVarName("offset",
                VariableType.DoubleVariable, true);

        // Calculate the variance based on the current value.
        double fractionOfCurrentValue = 0.1;
        IRTreeReturn<DoubleVariable> proposedVar = multiplyID(
                multiplyII(load(funcData.originalValueName), load(funcData.originalValueName)),
                multiplyDD(constant(fractionOfCurrentValue), constant(fractionOfCurrentValue)));
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(varName, proposedVar, "Calculate a proposed variance."));

        // Ensure it is not too small
        IRTreeReturn<BooleanVariable> guard = lessThan(load(varName), constant(1.0));
        IRTreeVoid ifStmt = store(varName, constant(1.0), Tree.NoComment);
        compilationCtx.addTreeToScope(GlobalScope.scope,
                IRTree.ifElse(guard, ifStmt, "Ensure the variance is at least 1"));

        // Sample a Gaussian distribution based on it.
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(
                        offsetName, functionCallReturn(FunctionType.SAMPLE, VariableType.DoubleVariable,
                                VariableType.Gaussian, constant(0.0), load(varName)),
                        "An offset for the current value"));

        // Ensure offset value is not 0
        guard = lessThanEqual(load(offsetName), constant(0.0));
        IRTreeReturn<DoubleVariable> ifValue = subtractDI(load(offsetName), constant(1));
        IRTreeReturn<DoubleVariable> elseValue = addDI(load(offsetName), constant(1));
        IRTreeReturn<DoubleVariable> offset = conditionalAssignment(guard, ifValue, elseValue);
        compilationCtx.addTreeToScope(GlobalScope.scope, store(offsetName, offset, "Make sure the offset is not 0"));

        // Construct the proposed value
        IRTreeReturn<IntVariable> proposedValueTree = addII(load(funcData.originalValueName),
                castToInteger(load(offsetName)));
        IRTreeVoid proposedValueTreeInit = initializeVariable(funcData.proposedValueName, proposedValueTree,
                "The proposed new value for the sample");
        compilationCtx.addTreeToScope(GlobalScope.scope, proposedValueTreeInit);
    }

    @Override
    public boolean canAcceptTraces(SampleTask<IntVariable, B> sample, List<String> suggestions,
            CompilationContext compilationCtx) {
        return true;
    }
}
